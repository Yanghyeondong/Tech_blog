{"componentChunkName":"component---src-templates-post-template-tsx","path":"/leetcode-121-explanation/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<h2 id=\"1-문제-확인\" style=\"position:relative;\"><a href=\"#1-%EB%AC%B8%EC%A0%9C-%ED%99%95%EC%9D%B8\" aria-label=\"1 문제 확인 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 문제 확인</h2>\n<p><a href=\"https://leetcode.com/problems/best-time-to-buy-and-sell-stock/\" target=\"_blank\" rel=\"nofollow\">121. Best Time to Buy and Sell Stock</a>\r\n<br>\n시간에 따른 주식 값이 주어지고, 가능한 <strong>최대 이익(차익)</strong> 을 구하는 문제입니다. 차익의 값만 구하면 되는 것이 포인트입니다.</p>\n<h2 id=\"2-코드\" style=\"position:relative;\"><a href=\"#2-%EC%BD%94%EB%93%9C\" aria-label=\"2 코드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 코드</h2>\n<p><strong>코드 1</strong><br>\n처리시간 2210 ms</p>\n<div class=\"gatsby-highlight\" data-language=\"py\"><pre class=\"language-py\"><code class=\"language-py\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">:</span>\r\n    <span class=\"token keyword\">def</span> <span class=\"token function\">maxProfit</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> prices<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">:</span>\r\n        left_min <span class=\"token operator\">=</span> prices<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span>\r\n        right_max <span class=\"token operator\">=</span> prices<span class=\"token punctuation\">[</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>prices<span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\r\n        left_mins <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\r\n        right_maxs <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\r\n        prices_len <span class=\"token operator\">=</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>prices<span class=\"token punctuation\">)</span>\r\n\r\n        <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> prices_len<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\r\n            left_min <span class=\"token operator\">=</span> <span class=\"token builtin\">min</span><span class=\"token punctuation\">(</span>left_min<span class=\"token punctuation\">,</span> prices<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\r\n            left_mins<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>left_min<span class=\"token punctuation\">)</span>\r\n            \r\n        <span class=\"token keyword\">for</span> j <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>prices_len <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\r\n            right_max <span class=\"token operator\">=</span> <span class=\"token builtin\">max</span><span class=\"token punctuation\">(</span>right_max<span class=\"token punctuation\">,</span> prices<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\r\n            right_maxs<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>right_max<span class=\"token punctuation\">)</span>\r\n\r\n        right_maxs<span class=\"token punctuation\">.</span>reverse<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\r\n\r\n        sub_max <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span>\r\n        <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> prices_len<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\r\n            sub_max <span class=\"token operator\">=</span> <span class=\"token builtin\">max</span><span class=\"token punctuation\">(</span>sub_max<span class=\"token punctuation\">,</span> right_maxs<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span> left_mins<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\r\n        <span class=\"token keyword\">if</span> sub_max <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\r\n            <span class=\"token keyword\">return</span> <span class=\"token number\">0</span>\r\n        <span class=\"token keyword\">return</span> sub_max</code></pre></div>\n<p><br>\n<strong>코드 2 (개선)</strong><br>\n처리시간 2140 ms</p>\n<div class=\"gatsby-highlight\" data-language=\"py\"><pre class=\"language-py\"><code class=\"language-py\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">:</span>\r\n    <span class=\"token keyword\">def</span> <span class=\"token function\">maxProfit</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> prices<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">:</span>\r\n        profit <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\r\n        min_price <span class=\"token operator\">=</span> sys<span class=\"token punctuation\">.</span>maxsize\r\n\r\n        <span class=\"token keyword\">for</span> price <span class=\"token keyword\">in</span> prices<span class=\"token punctuation\">:</span>\r\n            min_price <span class=\"token operator\">=</span> <span class=\"token builtin\">min</span><span class=\"token punctuation\">(</span>min_price<span class=\"token punctuation\">,</span> price<span class=\"token punctuation\">)</span>\r\n            profit <span class=\"token operator\">=</span> <span class=\"token builtin\">max</span><span class=\"token punctuation\">(</span>profit<span class=\"token punctuation\">,</span> price <span class=\"token operator\">-</span> min_price<span class=\"token punctuation\">)</span>\r\n\r\n        <span class=\"token keyword\">return</span> profit</code></pre></div>\n<h2 id=\"3-피드백\" style=\"position:relative;\"><a href=\"#3-%ED%94%BC%EB%93%9C%EB%B0%B1\" aria-label=\"3 피드백 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 피드백</h2>\n<p>이번에는 <strong>코드 1</strong>과 <strong>코드 2</strong>의 시간 차이가 크지 않습니다. 둘 다 <strong>O(n)</strong> 시간 복잡도를 가집니다.<br>\n<br>\n우선 <strong>코드 1</strong>의 경우 저번 문제 <a href=\"https://hyeondong.com/leetcode-238-explanation/\" target=\"_blank\" rel=\"nofollow\">238. Product of Array Except Self</a> 의 아이디어를 사용했습니다. 주요 아이디어를 정리해보면 다음과 같습니다.</p>\n<blockquote>\n<ol>\n<li>좌측 최솟값(저점)을 인덱스마다 리스트로 기록</li>\n<li>우측 최댓값(고점)을 인덱스마다 리스트로 기록</li>\n<li>동일한 인덱스에 한해 차이가 가장 큰 값이 최대 이익</li>\n</ol>\n</blockquote>\n<p>좌측 최솟값, 우측 최댓값을 기록한 이유는 시간상으로 <strong>저점</strong>이 <strong>고점</strong>보다 앞서야 하기 때문입니다. 즉, 좌측 최솟값을 기록하면 특정 인덱스 기준 <strong>가장 저점인 과거 값</strong>을 알 수가 있습니다. 반대로 우측 최댓값은 특정 인덱스 기준 <strong>가장 고점인 미래 값</strong>을 알 수가 있습니다. 이를 인덱스마다 확인해보면 최대 이익을 알 수가 있습니다. 예를 들어보면 다음과 같습니다.<br>\n<br>\n<code class=\"language-text\">[7, 1, 5, 3, 6, 4]</code> ➜ <code class=\"language-text\">prices</code><br>\n<code class=\"language-text\">[7, 1, 1, 1, 1, 1]</code> ➜ <code class=\"language-text\">left_mins</code><br>\n<code class=\"language-text\">[7, 6, 6, 6, 6, 4]</code> ➜ <code class=\"language-text\">right_max</code><br>\n<br>\n위의 예시에서 다시 한번 리스트를 순회하며 <code class=\"language-text\">left_mins</code> 와 <code class=\"language-text\">right_max</code> 의 차이를 계산했을 때 답은 최댓값인 5가 됩니다. 해당 알고리즘은 전체적으로 시간 복잡도 <strong>O(n)</strong> 이 됩니다.<br>\n<br>\n<strong>코드 2</strong>의 경우 매번 마다 마지막 저점 기준 고점과의 차익을 갱신하여 문제를 풉니다. 주요 아이디어를 정리해보면 다음과 같습니다.</p>\n<blockquote>\n<ol>\n<li>좌측 최솟값(저점)을 기억</li>\n<li>인덱스를 순회하며 저점을 갱신</li>\n<li>현재 지점 기준 저점과의 차익을 구함. 최대 이익 갱신</li>\n<li>리스트 끝까지 반복</li>\n</ol>\n</blockquote>\n<p>간단히 요약하면, 새로 저점이 갱신될 때마다 해당 저점을 기준으로 최대 이익을 구하고, 구간별 최대 이익중에서도 최댓값을 찾는 것입니다. <strong>코드 1</strong>과 방식이 거의 유사합니다. 차이점이 있다면 <strong>코드 1</strong>은 미리 전부 구해놓고 추후에 비교하는 것, <strong>코드 2</strong>는 실시간으로 비교하는 것입니다.<br>\n<br>\n<strong>코드 2</strong>에서 특이한 부분이라면 <code class=\"language-text\">min_price = sys.maxsize</code>를 꼽을 수 있습니다. 해당 코드를 쓴 이유는 다음 예시로 설명할 수 있습니다.<br>\n<br>\n<code class=\"language-text\">[100100, 150000, 120000, 180000, 190000, 200000]</code> ➜ <code class=\"language-text\">prices</code><br>\n<code class=\"language-text\">9999</code> ➜ <code class=\"language-text\">min_price</code><br>\n<br>\n위의 경우 최솟값을 임의로 높은 값을 설정했지만 실제로는 <code class=\"language-text\">prices</code> 모든 값이 <code class=\"language-text\">min_price</code> 보다 큽니다. 따라서 <code class=\"language-text\">min()</code> 함수를 반복해도 존재하지 않는 값인 <code class=\"language-text\">9999</code>가 답이 되어 버립니다. 이때 <code class=\"language-text\">sys.maxsize</code> 값을 할당하면 파이썬에서 가능한 큰 값이 할당되므로 안전합니다.<br>\n<br>\n<strong>코드 1</strong>의 경우 이를 생각하지 않고 단순히 <strong>첫 번째 리스트 값</strong>을 최솟값으로 할당했습니다. 이런 경우 존재하지 않는 값이 도출될 일은 없지만 코드가 좀 복잡해지거나 반복문에서 첫 번째 요소를 무의미하게 반복하는 단점이 존재합니다. 여기서는 본인이 생각하기에 편한 값으로 설정하면 될 것 같습니다.<br>\n<br>\n위의 맥락과 비슷하게 <strong>코드 1</strong>에선 <code class=\"language-text\">sub_max = -1</code> 로 범위를 설정했는데, 이는 문제에서 이익을 보지 못하면 0으로 설정하는 조건이 있었기 때문입니다. 만약 음수도 가능했다면 이것도 첫 차익 <code class=\"language-text\">right_maxs[0] - left_mins[0]</code> 로 정하거나 <code class=\"language-text\">-sys.maxsize</code>로 설정했어야 합니다.</p>\n<h2 id=\"4-요약정리\" style=\"position:relative;\"><a href=\"#4-%EC%9A%94%EC%95%BD%EC%A0%95%EB%A6%AC\" aria-label=\"4 요약정리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. 요약정리</h2>\n<p>문제를 그림으로 <strong>도식화</strong> 하면 풀이 아이디어나 직관이 쉽게 떠오른다.<br>\n시간에 따른 차익 문제에서는 최소 최댓값 <strong>기록 후</strong> 차익 계산, 혹은 <strong>동시 갱신</strong> 풀이가 가능하다.<br>\n최소나 최댓값을 설정할 때는 <strong>첫 번째 인자</strong>를 주거나 <code class=\"language-text\">sys.maxsize</code>를 사용하자.</p>\n<h2 id=\"source\" style=\"position:relative;\"><a href=\"#source\" aria-label=\"source permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Source</h2>\n<ul>\n<li>『파이썬 알고리즘 인터뷰』 <em>-박상길 지음</em></li>\n<li>leetcode<br>\n<a href=\"https://leetcode.com/problems/best-time-to-buy-and-sell-stock/\" target=\"_blank\" rel=\"nofollow\">https://leetcode.com/problems/best-time-to-buy-and-sell-stock/</a></li>\n</ul>","id":"4686159c-65de-57cd-b24a-755d967e0e4a","tableOfContents":"<ul>\n<li><a href=\"#1-%EB%AC%B8%EC%A0%9C-%ED%99%95%EC%9D%B8\">1. 문제 확인</a></li>\n<li><a href=\"#2-%EC%BD%94%EB%93%9C\">2. 코드</a></li>\n<li><a href=\"#3-%ED%94%BC%EB%93%9C%EB%B0%B1\">3. 피드백</a></li>\n<li><a href=\"#4-%EC%9A%94%EC%95%BD%EC%A0%95%EB%A6%AC\">4. 요약정리</a></li>\n<li><a href=\"#source\">Source</a></li>\n</ul>","frontmatter":{"title":"Leetcode 121번 풀이","summary":"Leetcode 121번 주식을 사고팔기 가장 좋은 시점 문제 풀이, 시간 복잡도 O(n)","date":"2022.09.16.","categories":["Algorithm","Leetcode"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAAsSAAALEgHS3X78AAACsUlEQVQozxXOSW/bRhgA0G9IDoc7OeImkpKGFCUukixqoazFkmzFtry0SRwEKYygyyVwji0KdEHuRg8+tZei/7bIL3gPqNHYDxex28WCaGmGqWih1xr0JpZqMjccZResnafNwFMaAnCmYi6LWZ1dcRzhEAc84nWC9+N9wmZ+kIbtstPKmNPcDudDVoq8JBEl740vF8dlf8gsagq8KioIIQAAnuMAAGMiE8WyQ9dtsXY2KU/7bnOWjMblq6ZlE4DYDw/T46ZY74uT1I7SeBB4DCRBQggJPOYBsCiFrbwXD9Pe9HJ5rLO51wgmebUZ1aGfWNHQs4PUCXzVcU0n7cxhU+yIqNNGpGg2xhLCpOmGs+EqYtXZeLkbHz0n7fjRbrLZzc/TfBm2cubYoeJgROBm9T5Ja1mjmhX4lqtgAgCqrBIsybK03d3Olm8WswuPer0ouV1cbCfn/XQ2GayrtIL7+i5mdRAmHICu0V7YDftLRFQAeHl5+eff/wDr5Wh9f/1YD1a+EyyK04j2RSLlyQDut+9W9ZvAZ9VgyfGKotD55MK12aenz09Pn3//7ct2swMApxlfHx7u9h8wrxOBM1XTskNIy7OIFQDQLxaLxR0gXpPNVpA9v/x9fPvdlz//+P6nTzJlmKi8IBTZdD09NtSGKitpdwx5snR0s2FQADjJqsPprSEaAHza7T8///Xrz7/oJo3qb9q9Nebw14Lp27Kp8aAhgJurH93OqKx2rP3Vn41W9/sPtuphkKjpGIaJAKmKXi6Op+v3Ie0AgMaDp2pU0aE8ufTicTHZX54/xEEXAOaj1evDxyZlVG0ZhKpEFxDmQGDd0d31D1X/DAmqIvK+TCCfXhGVtnvVtD68u3ls2b4AMB2sErYinJjZUduKPcWyiCkgyaLuw/Hx2/OPmtEWOPQ/dQZiuvvwAucAAAAASUVORK5CYII="},"images":{"fallback":{"src":"/static/bd5b96dad01a641177884d7f75cd6831/08547/leetcode.png","srcSet":"/static/bd5b96dad01a641177884d7f75cd6831/729aa/leetcode.png 200w,\n/static/bd5b96dad01a641177884d7f75cd6831/e75cb/leetcode.png 400w,\n/static/bd5b96dad01a641177884d7f75cd6831/08547/leetcode.png 800w","sizes":"(min-width: 800px) 800px, 100vw"},"sources":[{"srcSet":"/static/bd5b96dad01a641177884d7f75cd6831/56f1b/leetcode.webp 200w,\n/static/bd5b96dad01a641177884d7f75cd6831/56553/leetcode.webp 400w,\n/static/bd5b96dad01a641177884d7f75cd6831/db8f7/leetcode.webp 800w","type":"image/webp","sizes":"(min-width: 800px) 800px, 100vw"}]},"width":800,"height":513}},"publicURL":"/static/bd5b96dad01a641177884d7f75cd6831/leetcode.png"}}}}]}},"pageContext":{"slug":"/leetcode-121-explanation/"}},"staticQueryHashes":[]}