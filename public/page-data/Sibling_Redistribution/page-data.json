{"componentChunkName":"component---src-templates-post-template-tsx","path":"/Sibling_Redistribution/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<p><em>본 글은 성균관대학교 이상원 교수님의 “A Case for Space Compaction of B-Tree Nodes on Flash Storage” 논문을 바탕으로 작성하였습니다.</em></p>\n<h2 id=\"1-기존-btree-알고리즘의-한계\" style=\"position:relative;\"><a href=\"#1-%EA%B8%B0%EC%A1%B4-btree-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%98-%ED%95%9C%EA%B3%84\" aria-label=\"1 기존 btree 알고리즘의 한계 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 기존 b+tree 알고리즘의 한계</h2>\n<p>우선 기존의 b+tree알고리즘을 생각해보면 다음과 같은 일련의 과정으로 동작합니다.<br>\n<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 768px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/92ee9dac2b6594e543a2bcb08e8debd9/79586/001.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 37.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAIAAAB2/0i6AAAACXBIWXMAAAsTAAALEwEAmpwYAAABHElEQVQY03VQa2/kMAjc//8bq153nWQfiW0gBj9qTJW9qtv7cCOEEDAzgpP9QmutlFJLqQdazkVEcs61FFUdY9i/OL3KMbLkaV4+3PRxcfO8ODdFgMSCiVX1ufIdL/JPa5iF1cc/5/r27s4X59yy3MLtyvcrJ2Ims/Ef52MwTJtRHAgQY4yAhLvHeEZ3AecAYCAa0bf5qXfz3h4PAzCItnmLZLu8JD+7BRgAKmIHE4/c+5Oseih5r9NE14XnSRB0JyvFxt8XjaG9csIseyms2nrXUp7k1lqtXCsD+BDWEO7MyCyIuffeWtu2eL89YoScCwLO87Kum8jxwhMixeNAYJYYgGj3IRDRtq3MLCIpcUqJiJgZEYkIEYMPrbYvmUbNQSlE02EAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/92ee9dac2b6594e543a2bcb08e8debd9/a59e9/001.webp 192w,\n/static/92ee9dac2b6594e543a2bcb08e8debd9/0ca9f/001.webp 384w,\n/static/92ee9dac2b6594e543a2bcb08e8debd9/dc9b9/001.webp 768w,\n/static/92ee9dac2b6594e543a2bcb08e8debd9/21cee/001.webp 932w\"\n              sizes=\"(max-width: 768px) 100vw, 768px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/92ee9dac2b6594e543a2bcb08e8debd9/3b721/001.png 192w,\n/static/92ee9dac2b6594e543a2bcb08e8debd9/66595/001.png 384w,\n/static/92ee9dac2b6594e543a2bcb08e8debd9/fe486/001.png 768w,\n/static/92ee9dac2b6594e543a2bcb08e8debd9/79586/001.png 932w\"\n            sizes=\"(max-width: 768px) 100vw, 768px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/92ee9dac2b6594e543a2bcb08e8debd9/fe486/001.png\"\n            alt=\".\"\n            title=\".\"\n            loading=\"lazy\"\n            decoding=\"async\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span><br>\n<br>\n8이라는 새로운 값을 <code class=\"language-text\">leaf node</code>에 <code class=\"language-text\">insert</code> 할때, 만약 해당 <code class=\"language-text\">leaf node</code> 자리가 충분하지 않으면 split을 진행합니다. 위의 예시에는 <code class=\"language-text\">[2,3,5,7]</code>에 해당하는 노드가 <code class=\"language-text\">[2,3] + [5,7,8]</code> 로 분리되는 모습을 보여줍니다.<br>\n하지만  Sibling Redistribution을 이용하면 이러한 split을 하지 않아도 됩니다. 옆에 자리가 남아있는 <code class=\"language-text\">[14,16]</code>에 해당하는 <code class=\"language-text\">leaf node</code>에다가 <code class=\"language-text\">[2,3,5,7,8]</code> 을  Redistribution 하면 되기 때문입니다.\r\n예를 들자면 <code class=\"language-text\">[2,3,5]</code>와 <code class=\"language-text\">[7,8,14,16]</code>로, 혹은 <code class=\"language-text\">[2,3,5,7]</code>과 <code class=\"language-text\">[8,14,16]</code>로 Redistribution 할 수 있습니다.</p>\n<h2 id=\"2-sibling-redistribution-설명\" style=\"position:relative;\"><a href=\"#2-sibling-redistribution-%EC%84%A4%EB%AA%85\" aria-label=\"2 sibling redistribution 설명 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Sibling Redistribution 설명</h2>\n<p>참고 논문 : <a href=\"https://ieeexplore.ieee.org/document/10102447\" target=\"_blank\" rel=\"nofollow\">A Case for Space Compaction of B-Tree Nodes on Flash Storage</a></p>\n<p>위 논문의 4쪽 DATA REDISTRIBUTION 을 정리하면 다음과 같습니다.\r\n<code class=\"language-text\">NODE_cur</code>에 해당하는 <code class=\"language-text\">leaf node</code>에 새로운 값을 <code class=\"language-text\">REC_a</code> 를 넣는 상황을 가정해봅니다.<br>\n<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 401px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/cb9cb0cb04bf6dba47c265ceae5b0e6f/25946/002.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 38.541666666666664%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABdklEQVQoz11Sa4+jMAzs//9rlZZSDgJ50sDyaEtvWZKVKI85xXfth7MEwZY9zIxzUErjHCdgKYMUAlIZtF2HpmlRVTWklBBcgnOJ2+2OnOVIfmUYx2/wgiMvBJz3CLHvOw7z/MSyLFjXFc/nk4pt04IxBlOWUKpE9BFBmxLGhNzAWkt523Yw2iCQKgqByTkcAlCIdVlgbY0sTZEzDikVtDZgeQHBBQrO6TvUtFIQQkJIA1NeoITAKU7wPU04bNsGN03U0HU9nJsILE0zDMPjLSX0hXPfNlIT8tcT6uu/kwB/vCcAxgq0XY9xHP96xAXVr9c7doCGX0Hg+47/gyT/eAepNOq6RpKk6K83oh+kxvGZZHnv0Xc9Klvhs26gtaaf9f0VL9uIYXj9fjxoKDRrZeCcx2MYaAnB/Cg6wVY1WRMWcLlY2vpn02JZ1zfTt+ThfkN8TnCxFlnGaGj8+iJf0yzHR3SiK3Q8HlEIRbdinuc3sxdYkPwHo/lVpWXqFZAAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/cb9cb0cb04bf6dba47c265ceae5b0e6f/a59e9/002.webp 192w,\n/static/cb9cb0cb04bf6dba47c265ceae5b0e6f/0ca9f/002.webp 384w,\n/static/cb9cb0cb04bf6dba47c265ceae5b0e6f/44eaf/002.webp 401w\"\n              sizes=\"(max-width: 401px) 100vw, 401px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/cb9cb0cb04bf6dba47c265ceae5b0e6f/3b721/002.png 192w,\n/static/cb9cb0cb04bf6dba47c265ceae5b0e6f/66595/002.png 384w,\n/static/cb9cb0cb04bf6dba47c265ceae5b0e6f/25946/002.png 401w\"\n            sizes=\"(max-width: 401px) 100vw, 401px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/cb9cb0cb04bf6dba47c265ceae5b0e6f/25946/002.png\"\n            alt=\".\"\n            title=\".\"\n            loading=\"lazy\"\n            decoding=\"async\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span><br>\n<br>\n코드를 통해 위의 상황을 다음과 같이 정리합니다. 먼저 <code class=\"language-text\">NODE_cur</code> 노드 속에 기존의 <code class=\"language-text\">REC</code> 들이 가진 모든 <code class=\"language-text\">size</code>를 합쳐서 <code class=\"language-text\">used_space</code>를 계산하고 이를 다시 전체 사이즈에서 빼서 <code class=\"language-text\">free_space</code>의 크기를 계산합니다.\r\n다음으로 만약 새로 들어오는 <code class=\"language-text\">RECa</code> 의 크기가 해당 <code class=\"language-text\">free_space</code> 보다 크다면 이를 처리하기 위한 알고리즘으로 진입합니다. 만약 <code class=\"language-text\">free_space</code>가 더 크다면 그냥 간단히 <code class=\"language-text\">insert</code>만 하면 해당 함수는 끝나게 됩니다.<br>\n<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 394px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/efa895009248e11f90843df4cc6448e0/b2f6b/003.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 33.854166666666664%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAA7DAAAOwwHHb6hkAAABH0lEQVQoz22Qi27DIAxF+//ftm7SEggU0nUtCX0lTbflCeRO0KXbol4JCVv29bEXfT/AyxoDsRJYLp/BuEDTNCiLEnEU42n5Aq336PsOk8Zx/PP/jRfG2JuhtZBCghAKxjg2my2qqoLaqRBzvoLKNS7XK6x1oafrOgzGeMv7kIU38jLGYPu+hZQpCEnwGsWgCUOW5SiKAlIIRDEFSxjW6zeoLAdPGBIub4iTofkx9IF/OteBKE3XyLMcl+qK0+mEVKaglEHrQ6ib90273w2dtaAxxbko4ZzDMAzhDL7YWRc2mHKP7zi74ZRQSiGKCYSQOOwP+Pj8wvF4BGerQLhTGeqm/Uc3PlrZUzFCQQhD2/dwzqKu6xmFQ9O2oXZOOOkbSp8YBLxRu7cAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/efa895009248e11f90843df4cc6448e0/a59e9/003.webp 192w,\n/static/efa895009248e11f90843df4cc6448e0/0ca9f/003.webp 384w,\n/static/efa895009248e11f90843df4cc6448e0/1d0ae/003.webp 394w\"\n              sizes=\"(max-width: 394px) 100vw, 394px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/efa895009248e11f90843df4cc6448e0/3b721/003.png 192w,\n/static/efa895009248e11f90843df4cc6448e0/66595/003.png 384w,\n/static/efa895009248e11f90843df4cc6448e0/b2f6b/003.png 394w\"\n            sizes=\"(max-width: 394px) 100vw, 394px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/efa895009248e11f90843df4cc6448e0/b2f6b/003.png\"\n            alt=\".\"\n            title=\".\"\n            loading=\"lazy\"\n            decoding=\"async\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span><br>\n<br>\nSplit 혹은 Redistribution을 하기에 앞서 우선 <code class=\"language-text\">NODE_cur</code>의 좌우 Sibling 들을 <code class=\"language-text\">NODE_left</code>와 <code class=\"language-text\">NODE_right</code>로 지정해주고, 둘 중에서 더 큰 노드를 찾습니다. 그리고 그 노드를 Redistribution의 대상인 <code class=\"language-text\">NODE_target</code> 으로 만들어줍니다.<br>\n<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 398px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/5227d50044a9698fe9be8c932c65c324/2ab25/004.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 18.75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAz0lEQVQY05WP206DQBRF+f/fUh9sg6gpLRMKnWmhUEObYrk4F1imY/Tdnezs83DOyj7Brev5lcxyEpGSphlxHBO9vlPXNZfzhUNRsN1miETwEr2RJIKmadhJxfJ5wbW9eUYwDIMf5nlmnuGzbcnzHU1zZhxHD5BqT1VVHMsjUiqUVGzWGxbLkPJYURQlq1XM6fRB0PU/wGmafA59RxhGJEJ48L3Vfcc5izEWrTXWWpxz/kYbg7UOY4x3cG3bv5ezLOfx4Qm1P2Cs5Utrn//RN7iYLmrM8aNnAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/5227d50044a9698fe9be8c932c65c324/a59e9/004.webp 192w,\n/static/5227d50044a9698fe9be8c932c65c324/0ca9f/004.webp 384w,\n/static/5227d50044a9698fe9be8c932c65c324/b8520/004.webp 398w\"\n              sizes=\"(max-width: 398px) 100vw, 398px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/5227d50044a9698fe9be8c932c65c324/3b721/004.png 192w,\n/static/5227d50044a9698fe9be8c932c65c324/66595/004.png 384w,\n/static/5227d50044a9698fe9be8c932c65c324/2ab25/004.png 398w\"\n            sizes=\"(max-width: 398px) 100vw, 398px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/5227d50044a9698fe9be8c932c65c324/2ab25/004.png\"\n            alt=\".\"\n            title=\".\"\n            loading=\"lazy\"\n            decoding=\"async\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span><br>\n<br>\n다음으로는 만약 <code class=\"language-text\">NODE_target</code>의 사이즈가 <code class=\"language-text\">NODE_cur</code>사이즈보다 크다면 <code class=\"language-text\">split_rec_insert()</code>을 수행하여 기존처럼 split을 진행합니다.<br>\n<br>\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 363px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/e13a6ba103ca1e32b8fbfa2eac085679/6ddef/005.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 80.20833333333334%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACR0lEQVQ4y41UiZKqMBDk/79sawVcUU5FFBEE5BDx4LJfzSgsu/uuqUqRUJmeTk8nwuFwwL2qQHEpz9ANE6IoQZ5+II6PSJMEtEfTNLy/i3DdHaayjOXSxjMeaNv2OXs8IKRpgqZp0UfXdVjba+iazuBxHENR5tjvfRi6jpXtYL12+N/1dsMpz2CY1pAvUEJdN0MFGhSBHzAbx9nA0E3I8hSWtUSaEoCJyUSEaS6ZqabpCMOIyQhRFKEaAdIR6BsEAUzDhGFYmM8X2G5dBiMCVMjzPKiqCnvtII5iSJKMNE1/AvYMKTaOg8lEQp7nvO61+h7jnC+AfdxuV0iiBGW+QNM0g7Z9QRq0Hv/r50IUhqiqemBAbIiZs9miKIp/MvrB8EhNebGoqjsLH8UxA+f5iYuEYYjr9YoszXA8Jrw3zzLEx2SQgfbTXKDN5MNxFRLctm1sNlv2oKrqMAyTreLtfbhblyXZbHfIsgw714VlWmjaDgLZoxkZs3sBezsPq5UNVdW4y7L8Add1kWU5fD/gArpmQF2oEEUZQRCirmsIVV0jimLY9pqF7RtwOp1Yw7K8MAs6alGcOampa5RliYQlOCJJU/bh7XaHcL/fOZGqjgEpyvLMt+JPzfldCHEUoW27zyO/wKhZykyBZa1wuVy++PRvg7tMx6YbMjRlt8Pb2ztrOL7jY79992XfVL7LT0CwPqZuQJmrKM7nge3/BjP0fX94vsiH9EQRu/xU8FH33h6zmcKvDDnCth0es9kcge/zo+Htg/4lwy/C8MOltMEB9gAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/e13a6ba103ca1e32b8fbfa2eac085679/a59e9/005.webp 192w,\n/static/e13a6ba103ca1e32b8fbfa2eac085679/c25a5/005.webp 363w\"\n              sizes=\"(max-width: 363px) 100vw, 363px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/e13a6ba103ca1e32b8fbfa2eac085679/3b721/005.png 192w,\n/static/e13a6ba103ca1e32b8fbfa2eac085679/6ddef/005.png 363w\"\n            sizes=\"(max-width: 363px) 100vw, 363px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/e13a6ba103ca1e32b8fbfa2eac085679/6ddef/005.png\"\n            alt=\".\"\n            title=\".\"\n            loading=\"lazy\"\n            decoding=\"async\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span><br>\n<br>\n이전의 경우가 아닌 경우, 본격적으로 Sibling Redistribution 을 진행합니다. 우선 <code class=\"language-text\">NODE_left</code>를 <code class=\"language-text\">NODE_target</code> 로 한 경우, <code class=\"language-text\">NODE_left</code>에 <code class=\"language-text\">NODE_cur</code> 의 REC를 계속 넘깁니다. 이것이 멈추는 시점은 바로 <code class=\"language-text\">NODE_cur</code> 의 크기가 <code class=\"language-text\">NODEleft</code>크기와 같거나 작아지는 시점입니다. 교안의 설명 “현재 insert가 발생하는 노드와 redistribution target sibling 노드가 저장하고 있는 레코드 개수가 같아질 때까지 옮긴다.”에 해당합니다.</p>\n<p>결론적으로 이러한 방식은 기존 split의 횟수를 줄임으로서 같은 데이터의 양을 더 적은 node에 담을 수 있습니다. 이는 결국 in-use space 을 줄여서 I/O performance 와 transaction throughput 을 향상시키고 space utilization을 높인다. 이러한 방식은 SSD와 같은 장비에서 더욱 높은 효과를 보여줍니다.</p>\n<h2 id=\"source\" style=\"position:relative;\"><a href=\"#source\" aria-label=\"source permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Source</h2>\n<ul>\n<li>『A Case for Space Compaction of B-Tree Nodes on Flash Storage』 <em>Bo-Hyun Lee; Mijin An; Sang-Won Lee; - 지음</em><br>\n<a href=\"https://ieeexplore.ieee.org/document/10102447\" target=\"_blank\" rel=\"nofollow\">https://ieeexplore.ieee.org/document/10102447</a></li>\n</ul>","id":"50ad89a7-c670-5a0a-abb1-09dfd964747f","tableOfContents":"<ul>\n<li><a href=\"#1-%EA%B8%B0%EC%A1%B4-btree-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%98-%ED%95%9C%EA%B3%84\">1. 기존 b+tree 알고리즘의 한계</a></li>\n<li><a href=\"#2-sibling-redistribution-%EC%84%A4%EB%AA%85\">2. Sibling Redistribution 설명</a></li>\n<li><a href=\"#source\">Source</a></li>\n</ul>","frontmatter":{"title":"DB 알고리즘 Sibling Redistribution 개념 이해하기","summary":"실제 논문과 함께 Sibling Redistribution 개념에 대해 알아봅니다.","date":"2024.05.15.","categories":["DB","Tip"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/2wBDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/wgARCAALABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAgDBgf/xAAXAQADAQAAAAAAAAAAAAAAAAAEBQYH/9oADAMBAAIQAxAAAAGPHq+/1bl6nDMhCv8A/8QAGhAAAwEAAwAAAAAAAAAAAAAABAUGAwABEv/aAAgBAQABBQKXktTubp18/aN4ofYjBuxm1UQOObKndetf/8QAIhEAAgECBQUAAAAAAAAAAAAAAQIDBBIABREhIhMkMWGR/9oACAEDAQE/ASzU6VFSWuhPb9IagCV0ksa1me+OJQ72vJylIY7kuBmFTHwErC0kbCM+D7TX7j//xAAfEQACAQQCAwAAAAAAAAAAAAABAhEAAyFhEjITYoH/2gAIAQIBAT8B7tbtxDd+XqGQESAsMxIGFwo+V4LTZKDO21uv/8QAJhAAAgICAQMCBwAAAAAAAAAAAgMBBAUREwASIQYUFSIkMTJBQ//aAAgBAQAGPwKyy0vHY6+eLOtWqYxkWruMq2Z0dzIEbOX3r1wA1Gk/Q98jMbAh6wnofAttOsPx7LOXvM1abFIil/tYiYBCFyhX1IgtxkThncwQgK+CCpLWgFwitX41x87D/GJHRaOIne58ff8AUVbOEsTj7OWwqL2QsLWk32LSn20LZyuWxi+1f80ktUnJNkJaZHOKzNquh2WyePBuQyZpX8Qtn2zG23IGLE+FrjXJ26AY146Ap8ySVzM7nzM76//EABkQAQADAQEAAAAAAAAAAAAAAAEAESFBMf/aAAgBAQABPyELOaTPMgUrssOWhZ3liyjOoJp6O3TA80Xx35gjcI4MSUGAtC46vSzTJDagRQkK59VgFxDZ/9oADAMBAAIAAwAAABBz3//EABgRAQEBAQEAAAAAAAAAAAAAAAERIQAx/9oACAEDAQE/EFsLInXeVCYmJ1joIkGMWLoox15hp3//xAAZEQEBAQEBAQAAAAAAAAAAAAABESFBMWH/2gAIAQIBAT8QJkkloqiqUN2QKA1lhArPnBJg4Z59v//EABgQAQEBAQEAAAAAAAAAAAAAAAEAESFB/9oACAEBAAE/ED68fha9i490Zkt0o85GvATBOMYtjvFBaZZExHuacAwhQByYM/KSMonYrpSmtmNE2CK64B4AX//Z"},"images":{"fallback":{"src":"/static/e88ddafdbccd7f8da9f2b7e44d237451/7268e/net1.jpg","srcSet":"/static/e88ddafdbccd7f8da9f2b7e44d237451/175be/net1.jpg 960w,\n/static/e88ddafdbccd7f8da9f2b7e44d237451/8cf01/net1.jpg 1920w,\n/static/e88ddafdbccd7f8da9f2b7e44d237451/7268e/net1.jpg 3840w","sizes":"(min-width: 3840px) 3840px, 100vw"},"sources":[{"srcSet":"/static/e88ddafdbccd7f8da9f2b7e44d237451/eeb31/net1.webp 960w,\n/static/e88ddafdbccd7f8da9f2b7e44d237451/702da/net1.webp 1920w,\n/static/e88ddafdbccd7f8da9f2b7e44d237451/e9e05/net1.webp 3840w","type":"image/webp","sizes":"(min-width: 3840px) 3840px, 100vw"}]},"width":3840,"height":2160}},"publicURL":"/static/e88ddafdbccd7f8da9f2b7e44d237451/net1.jpg"}}}}]}},"pageContext":{"slug":"/Sibling_Redistribution/"}},"staticQueryHashes":[]}