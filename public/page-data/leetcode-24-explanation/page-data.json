{"componentChunkName":"component---src-templates-post-template-tsx","path":"/leetcode-24-explanation/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<h2 id=\"1-문제-확인\" style=\"position:relative;\"><a href=\"#1-%EB%AC%B8%EC%A0%9C-%ED%99%95%EC%9D%B8\" aria-label=\"1 문제 확인 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 문제 확인</h2>\n<p><a href=\"https://leetcode.com/problems/swap-nodes-in-pairs/\" target=\"_blank\" rel=\"nofollow\">24. Swap Nodes in Pairs</a>\r\n<br>\n주어진 연결 리스트에서 노드를 순서대로 2개씩 <strong>짝지어 스왑</strong> 하는 문제입니다. 노드 내부의 값을 변경하면 안 되는 것이 포인트입니다.</p>\n<blockquote>\n<p><strong>leetcode 설명</strong><br>\nYou must solve the problem without modifying the values in the list’s nodes<br>\n(i.e., only nodes themselves may be changed.)</p>\n</blockquote>\n<h2 id=\"2-코드\" style=\"position:relative;\"><a href=\"#2-%EC%BD%94%EB%93%9C\" aria-label=\"2 코드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 코드</h2>\n<p><strong>코드 1</strong><br>\n처리시간 55ms</p>\n<div class=\"gatsby-highlight\" data-language=\"py\"><pre class=\"language-py\"><code class=\"language-py\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">:</span>\r\n    <span class=\"token keyword\">def</span> <span class=\"token function\">swapPairs</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> head<span class=\"token punctuation\">:</span> Optional<span class=\"token punctuation\">[</span>ListNode<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> Optional<span class=\"token punctuation\">[</span>ListNode<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\r\n        \r\n        <span class=\"token keyword\">if</span> <span class=\"token keyword\">not</span> <span class=\"token punctuation\">(</span>head <span class=\"token keyword\">and</span> head<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\r\n            <span class=\"token keyword\">return</span> head\r\n\r\n        prev_node <span class=\"token operator\">=</span> ListNode<span class=\"token punctuation\">(</span><span class=\"token boolean\">None</span><span class=\"token punctuation\">)</span>\r\n        first_node <span class=\"token operator\">=</span> head\r\n        second_node <span class=\"token operator\">=</span> ans_head <span class=\"token operator\">=</span> head<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span>\r\n        \r\n        <span class=\"token keyword\">while</span> second_node<span class=\"token punctuation\">:</span>\r\n\r\n            next_node <span class=\"token operator\">=</span> second_node<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span>\r\n            second_node<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span><span class=\"token punctuation\">,</span> first_node<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span><span class=\"token punctuation\">,</span> prev_node<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span> <span class=\"token operator\">=</span> first_node<span class=\"token punctuation\">,</span> next_node<span class=\"token punctuation\">,</span> second_node\r\n\r\n            <span class=\"token keyword\">if</span> <span class=\"token keyword\">not</span> next_node<span class=\"token punctuation\">:</span>\r\n                <span class=\"token keyword\">break</span>\r\n\r\n            first_node<span class=\"token punctuation\">,</span> second_node<span class=\"token punctuation\">,</span> prev_node <span class=\"token operator\">=</span> next_node<span class=\"token punctuation\">,</span> next_node<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span><span class=\"token punctuation\">,</span> first_node\r\n\r\n        <span class=\"token keyword\">return</span> ans_head</code></pre></div>\n<p><br>\n<strong>코드 2 (개선)</strong><br>\n처리시간 52ms</p>\n<div class=\"gatsby-highlight\" data-language=\"py\"><pre class=\"language-py\"><code class=\"language-py\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">:</span>\r\n    <span class=\"token keyword\">def</span> <span class=\"token function\">swapPairs</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> head<span class=\"token punctuation\">:</span> ListNode<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> ListNode<span class=\"token punctuation\">:</span>\r\n\r\n        root <span class=\"token operator\">=</span> prev <span class=\"token operator\">=</span> ListNode<span class=\"token punctuation\">(</span><span class=\"token boolean\">None</span><span class=\"token punctuation\">)</span>\r\n        prev<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span> <span class=\"token operator\">=</span> head\r\n\r\n        <span class=\"token keyword\">while</span> head <span class=\"token keyword\">and</span> head<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span><span class=\"token punctuation\">:</span>\r\n            b <span class=\"token operator\">=</span> head<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span>\r\n            head<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span> <span class=\"token operator\">=</span> b<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span>\r\n            b<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span> <span class=\"token operator\">=</span> head\r\n\r\n            prev<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span> <span class=\"token operator\">=</span> b\r\n            head <span class=\"token operator\">=</span> head<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span>\r\n            prev <span class=\"token operator\">=</span> prev<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span><span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span>\r\n\r\n        <span class=\"token keyword\">return</span> root<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span></code></pre></div>\n<p><br>\n<strong>코드 3 (개선)</strong><br>\n처리시간 47ms</p>\n<div class=\"gatsby-highlight\" data-language=\"py\"><pre class=\"language-py\"><code class=\"language-py\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">:</span>\r\n    <span class=\"token keyword\">def</span> <span class=\"token function\">swapPairs</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> head<span class=\"token punctuation\">:</span> ListNode<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> ListNode<span class=\"token punctuation\">:</span>\r\n        <span class=\"token keyword\">if</span> head <span class=\"token keyword\">and</span> head<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span><span class=\"token punctuation\">:</span>\r\n            p <span class=\"token operator\">=</span> head<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span>\r\n            head<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span> <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>swapPairs<span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span><span class=\"token punctuation\">)</span>\r\n            p<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span> <span class=\"token operator\">=</span> head\r\n            <span class=\"token keyword\">return</span> p\r\n        <span class=\"token keyword\">return</span> head</code></pre></div>\n<h2 id=\"3-피드백\" style=\"position:relative;\"><a href=\"#3-%ED%94%BC%EB%93%9C%EB%B0%B1\" aria-label=\"3 피드백 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 피드백</h2>\n<p>이번에는 직접 작성한 <strong>코드 1</strong>과 책에 있는 <strong>코드 2</strong>의 접근법이 유사합니다. 다만, 여전히 <strong>코드 1</strong>은 예외처리나 반복문 조건 등에서 상대적으로 깔끔하지 못한 모습을 보입니다. <strong>재귀</strong>를 사용한 <strong>코드 3</strong>의 경우 가장 공간 복잡도가 적으면서도 아주 간결하게 보입니다. 가능한 최선이라고 볼 수 있습니다.<br>\n<br>\n<strong>코드 1</strong>과 <strong>코드 2</strong>의 기본적인 아이디어는 다음과 같습니다.</p>\n<blockquote>\n<ol>\n<li>최초의 <code class=\"language-text\">prev</code>(root) 노드를 만들어 준다.</li>\n<li>이후 순차적으로 2개의 노드 pair를 골라 <strong>스왑</strong>한다.</li>\n<li>스왑이 끝나면 이전 <code class=\"language-text\">prev</code> 노드와 연결하고 새로운 <code class=\"language-text\">prev</code> 노드를 다음 반복문으로 넘겨준다.</li>\n</ol>\n</blockquote>\n<p>여기서 <strong>코드 1</strong>이 <strong>코드 2</strong>에 비해 부족했던 점을 정리해보면 다음과 같습니다.</p>\n<ul>\n<li>불필요한 다중 할당이 많아 직관적이지 못하다.</li>\n<li><code class=\"language-text\">if not (head and head.next):</code> , <code class=\"language-text\">if not next_node:</code> 등 예외 조건이 많다.</li>\n</ul>\n<p><strong>다중 할당</strong>의 경우 한 줄로 스왑 등의 기능을 편하게 이용할 수 있는 장점이 있지만 길어질 경우 직관성이 떨어집니다.\r\n예를 들어 <strong>코드 1</strong>의 <code class=\"language-text\">second_node.next, first_node.next, prev_node.next = first_node, next_node, second_node</code>의\r\n경우 마지막 <code class=\"language-text\">prev_node.next</code>는 밑줄에 따로 써도 문제가 없고 더 직관적입니다. 하지만 줄 수를 줄이기 위해 다중 할당을 쓴 결과 오히려 가독성이 떨어졌습니다.<br>\n<br>\n다음으로 예외 조건입니다. <strong>코드 1</strong>의 경우 <code class=\"language-text\">None</code> 타입에 대해서 <code class=\"language-text\">.next</code>를 사용할 경우 런타임 오류가 발생하기에  <code class=\"language-text\">while second_node:</code>, <code class=\"language-text\">if not next_node:</code> 등의 조건을 붙였습니다.<br>\n하지만 <strong>코드 2</strong>의 경우 <code class=\"language-text\">while head and head.next:</code> 조건 하나만으로 이를 해결합니다. 이것이 가능한 이유는 <code class=\"language-text\">head</code>가 <code class=\"language-text\">None</code>일 경우 <code class=\"language-text\">and</code> 연산의 특성으로 인해 해당 조건문의 판정이 바로 끝나기 때문입니다. 즉, <code class=\"language-text\">head.next</code> 인한 오류 전에 계산이 끝납니다.<br>\n<br>\n이처럼 전반적으로 비슷한 접근법과 아이디어 일지라도, 코드를 좀 더 직관적이고 가독성 있게 표현하는 능력을 길러야겠습니다. 😔<br>\n<br>\n마지막으로 <strong>코드 3</strong>은 <strong>재귀</strong>를 통해 문제를 매우 세련되게 풉니다. 기본적인 아이디어를 정리해 보면 다음과 같습니다.</p>\n<blockquote>\n<ol>\n<li>순차적으로 2개의 노드 pair를 고른다.</li>\n<li>pair 중 앞선 노드(스왑 후 뒤따르는 노드)의 <code class=\"language-text\">.next</code>를 재귀 함수를 통해 호출한다.</li>\n<li>노드가 <code class=\"language-text\">None</code>일 경우 자기 자신을, 이외에는 스왑이 끝난 pair 중 앞선 노드를 리턴한다.</li>\n<li>백 트래킹을 통해 <code class=\"language-text\">.next</code> 가 정해지면 다음 pair와 연결되면서 노드가 스왑 된다.</li>\n<li>최초로 돌아갈 때까지 이를 반복한다.</li>\n</ol>\n</blockquote>\n<p>이러한 방식은 변수도 굉장히 적게 사용하고 코드도 최소한으로 사용하게 되어 모든 면에서 우위라고 생각합니다. 필자의 경우 처음부터 반복문으로 풀 생각이었는데, 재귀로 도전했어도 이런 해답에 도달하기는 힘들었을 것입니다. 아직도 배워야 할 점이 산더미처럼 남아있는 기분입니다. 😥</p>\n<h2 id=\"4-요약정리\" style=\"position:relative;\"><a href=\"#4-%EC%9A%94%EC%95%BD%EC%A0%95%EB%A6%AC\" aria-label=\"4 요약정리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. 요약정리</h2>\n<p>불필요한 <strong>다중 할당</strong>은 가독성을 떨어뜨린다.<br>\n조건문 내에서 <code class=\"language-text\">and</code> 연산의 특성을 활용해 런타임 오류와 예외 상황 코드를 줄여보자.<br>\n<strong>재귀</strong> 방식을 통해 더 적은 변수, 공간 복잡도를 도전해보자.</p>\n<h2 id=\"source\" style=\"position:relative;\"><a href=\"#source\" aria-label=\"source permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Source</h2>\n<ul>\n<li>『파이썬 알고리즘 인터뷰』 <em>-박상길 지음</em><br>\n<a href=\"https://github.com/onlybooks/algorithm-interview\" target=\"_blank\" rel=\"nofollow\">https://github.com/onlybooks/algorithm-interview</a></li>\n<li>leetcode<br>\n<a href=\"https://leetcode.com/problems/swap-nodes-in-pairs/submissions/\" target=\"_blank\" rel=\"nofollow\">https://leetcode.com/problems/swap-nodes-in-pairs/submissions/</a></li>\n</ul>","id":"4bc962e6-974f-55c7-8442-fb0e9b9aca1a","tableOfContents":"<ul>\n<li><a href=\"#1-%EB%AC%B8%EC%A0%9C-%ED%99%95%EC%9D%B8\">1. 문제 확인</a></li>\n<li><a href=\"#2-%EC%BD%94%EB%93%9C\">2. 코드</a></li>\n<li><a href=\"#3-%ED%94%BC%EB%93%9C%EB%B0%B1\">3. 피드백</a></li>\n<li><a href=\"#4-%EC%9A%94%EC%95%BD%EC%A0%95%EB%A6%AC\">4. 요약정리</a></li>\n<li><a href=\"#source\">Source</a></li>\n</ul>","frontmatter":{"title":"Leetcode 24번 풀이","summary":"Leetcode 24번 페어의 노드 스왑 문제 풀이, and 연산 특징, 재귀 함수","date":"2022.11.01.","categories":["Algorithm","Leetcode"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAAsSAAALEgHS3X78AAACsUlEQVQozxXOSW/bRhgA0G9IDoc7OeImkpKGFCUukixqoazFkmzFtry0SRwEKYygyyVwji0KdEHuRg8+tZei/7bIL3gPqNHYDxex28WCaGmGqWih1xr0JpZqMjccZResnafNwFMaAnCmYi6LWZ1dcRzhEAc84nWC9+N9wmZ+kIbtstPKmNPcDudDVoq8JBEl740vF8dlf8gsagq8KioIIQAAnuMAAGMiE8WyQ9dtsXY2KU/7bnOWjMblq6ZlE4DYDw/T46ZY74uT1I7SeBB4DCRBQggJPOYBsCiFrbwXD9Pe9HJ5rLO51wgmebUZ1aGfWNHQs4PUCXzVcU0n7cxhU+yIqNNGpGg2xhLCpOmGs+EqYtXZeLkbHz0n7fjRbrLZzc/TfBm2cubYoeJgROBm9T5Ja1mjmhX4lqtgAgCqrBIsybK03d3Olm8WswuPer0ouV1cbCfn/XQ2GayrtIL7+i5mdRAmHICu0V7YDftLRFQAeHl5+eff/wDr5Wh9f/1YD1a+EyyK04j2RSLlyQDut+9W9ZvAZ9VgyfGKotD55MK12aenz09Pn3//7ct2swMApxlfHx7u9h8wrxOBM1XTskNIy7OIFQDQLxaLxR0gXpPNVpA9v/x9fPvdlz//+P6nTzJlmKi8IBTZdD09NtSGKitpdwx5snR0s2FQADjJqsPprSEaAHza7T8///Xrz7/oJo3qb9q9Nebw14Lp27Kp8aAhgJurH93OqKx2rP3Vn41W9/sPtuphkKjpGIaJAKmKXi6Op+v3Ie0AgMaDp2pU0aE8ufTicTHZX54/xEEXAOaj1evDxyZlVG0ZhKpEFxDmQGDd0d31D1X/DAmqIvK+TCCfXhGVtnvVtD68u3ls2b4AMB2sErYinJjZUduKPcWyiCkgyaLuw/Hx2/OPmtEWOPQ/dQZiuvvwAucAAAAASUVORK5CYII="},"images":{"fallback":{"src":"/static/bd5b96dad01a641177884d7f75cd6831/08547/leetcode.png","srcSet":"/static/bd5b96dad01a641177884d7f75cd6831/729aa/leetcode.png 200w,\n/static/bd5b96dad01a641177884d7f75cd6831/e75cb/leetcode.png 400w,\n/static/bd5b96dad01a641177884d7f75cd6831/08547/leetcode.png 800w","sizes":"(min-width: 800px) 800px, 100vw"},"sources":[{"srcSet":"/static/bd5b96dad01a641177884d7f75cd6831/56f1b/leetcode.webp 200w,\n/static/bd5b96dad01a641177884d7f75cd6831/56553/leetcode.webp 400w,\n/static/bd5b96dad01a641177884d7f75cd6831/db8f7/leetcode.webp 800w","type":"image/webp","sizes":"(min-width: 800px) 800px, 100vw"}]},"width":800,"height":513}},"publicURL":"/static/bd5b96dad01a641177884d7f75cd6831/leetcode.png"}}}}]}},"pageContext":{"slug":"/leetcode-24-explanation/"}},"staticQueryHashes":[]}