{"componentChunkName":"component---src-templates-post-template-tsx","path":"/leetcode-23-explanation/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<h2 id=\"1-문제-확인\" style=\"position:relative;\"><a href=\"#1-%EB%AC%B8%EC%A0%9C-%ED%99%95%EC%9D%B8\" aria-label=\"1 문제 확인 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 문제 확인</h2>\n<p><a href=\"https://leetcode.com/problems/merge-k-sorted-lists/\" target=\"_blank\" rel=\"nofollow\">23. Merge k Sorted Lists</a>\r\n<br>\n<strong>정렬된</strong> 연결 리스트를 <strong>k</strong>개 받습니다. 각 리스트의 노드들을 <strong>오름차 순</strong>으로 정렬하여 <strong>하나의</strong> 연결 리스트를 만들면 됩니다. hard 난이도로 소개됩니다.</p>\n<h2 id=\"2-코드\" style=\"position:relative;\"><a href=\"#2-%EC%BD%94%EB%93%9C\" aria-label=\"2 코드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 코드</h2>\n<p><strong>코드 1</strong><br>\n처리시간 Time Limit Exceeded</p>\n<div class=\"gatsby-highlight\" data-language=\"py\"><pre class=\"language-py\"><code class=\"language-py\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">ListNode</span><span class=\"token punctuation\">:</span>\r\n    <span class=\"token keyword\">def</span> <span class=\"token function\">__init__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\r\n        self<span class=\"token punctuation\">.</span>val <span class=\"token operator\">=</span> x\r\n        self<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">None</span>\r\n\r\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">:</span>\r\n    <span class=\"token keyword\">def</span> <span class=\"token function\">mergeKLists</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> lists<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span>ListNode<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> ListNode<span class=\"token punctuation\">:</span>\r\n        <span class=\"token keyword\">if</span> <span class=\"token keyword\">not</span> lists<span class=\"token punctuation\">:</span>\r\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">None</span>\r\n        \r\n        root <span class=\"token operator\">=</span> tail <span class=\"token operator\">=</span> ListNode<span class=\"token punctuation\">(</span>sys<span class=\"token punctuation\">.</span>maxsize<span class=\"token punctuation\">)</span>\r\n        lists_empty <span class=\"token operator\">=</span> <span class=\"token boolean\">False</span>\r\n        heads <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token builtin\">list</span> <span class=\"token keyword\">for</span> <span class=\"token builtin\">list</span> <span class=\"token keyword\">in</span> lists<span class=\"token punctuation\">]</span>\r\n        \r\n        <span class=\"token keyword\">while</span> <span class=\"token keyword\">not</span> lists_empty<span class=\"token punctuation\">:</span>\r\n            min_node <span class=\"token operator\">=</span> root\r\n            min_index <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\r\n            \r\n            <span class=\"token keyword\">for</span> i<span class=\"token punctuation\">,</span> head <span class=\"token keyword\">in</span> <span class=\"token builtin\">enumerate</span><span class=\"token punctuation\">(</span>heads<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\r\n                <span class=\"token keyword\">if</span> <span class=\"token keyword\">not</span> head<span class=\"token punctuation\">:</span>\r\n                    <span class=\"token keyword\">continue</span>\r\n                <span class=\"token keyword\">if</span> min_node<span class=\"token punctuation\">.</span>val <span class=\"token operator\">>=</span> head<span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">:</span>\r\n                    min_node <span class=\"token operator\">=</span> head\r\n                    min_index <span class=\"token operator\">=</span> i\r\n\r\n            <span class=\"token keyword\">if</span> min_node<span class=\"token punctuation\">.</span>val <span class=\"token operator\">!=</span> sys<span class=\"token punctuation\">.</span>maxsize<span class=\"token punctuation\">:</span>\r\n                tail<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span> <span class=\"token operator\">=</span> min_node\r\n                tail <span class=\"token operator\">=</span> tail<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span>\r\n                heads<span class=\"token punctuation\">[</span>min_index<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> min_node<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span>\r\n                tail<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">None</span>\r\n\r\n            lists_empty <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span>\r\n            <span class=\"token keyword\">for</span> head <span class=\"token keyword\">in</span> heads<span class=\"token punctuation\">:</span>\r\n                <span class=\"token keyword\">if</span> head<span class=\"token punctuation\">:</span>\r\n                    lists_empty <span class=\"token operator\">=</span> <span class=\"token boolean\">False</span>\r\n\r\n        <span class=\"token keyword\">return</span> root<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span></code></pre></div>\n<p><br>\n<strong>코드 2 (개선)</strong><br>\n처리시간 181ms</p>\n<div class=\"gatsby-highlight\" data-language=\"py\"><pre class=\"language-py\"><code class=\"language-py\"><span class=\"token keyword\">import</span> heapq\r\n<span class=\"token keyword\">from</span> typing <span class=\"token keyword\">import</span> List\r\n\r\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">ListNode</span><span class=\"token punctuation\">:</span>\r\n    <span class=\"token keyword\">def</span> <span class=\"token function\">__init__</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\r\n        self<span class=\"token punctuation\">.</span>val <span class=\"token operator\">=</span> x\r\n        self<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">None</span>\r\n\r\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Solution</span><span class=\"token punctuation\">:</span>\r\n    <span class=\"token keyword\">def</span> <span class=\"token function\">mergeKLists</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> lists<span class=\"token punctuation\">:</span> List<span class=\"token punctuation\">[</span>ListNode<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> ListNode<span class=\"token punctuation\">:</span>\r\n        root <span class=\"token operator\">=</span> result <span class=\"token operator\">=</span> ListNode<span class=\"token punctuation\">(</span><span class=\"token boolean\">None</span><span class=\"token punctuation\">)</span>\r\n        heap <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\r\n\r\n        <span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>lists<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\r\n            <span class=\"token keyword\">if</span> lists<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\r\n                heapq<span class=\"token punctuation\">.</span>heappush<span class=\"token punctuation\">(</span>heap<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>lists<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">,</span> lists<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\r\n\r\n        <span class=\"token keyword\">while</span> heap<span class=\"token punctuation\">:</span>\r\n            node <span class=\"token operator\">=</span> heapq<span class=\"token punctuation\">.</span>heappop<span class=\"token punctuation\">(</span>heap<span class=\"token punctuation\">)</span>\r\n            idx <span class=\"token operator\">=</span> node<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\r\n            result<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span> <span class=\"token operator\">=</span> node<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span>\r\n\r\n            result <span class=\"token operator\">=</span> result<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span>\r\n            <span class=\"token keyword\">if</span> result<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span><span class=\"token punctuation\">:</span>\r\n                heapq<span class=\"token punctuation\">.</span>heappush<span class=\"token punctuation\">(</span>heap<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span><span class=\"token punctuation\">.</span>val<span class=\"token punctuation\">,</span> idx<span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\r\n\r\n        <span class=\"token keyword\">return</span> root<span class=\"token punctuation\">.</span><span class=\"token builtin\">next</span></code></pre></div>\n<h2 id=\"3-피드백\" style=\"position:relative;\"><a href=\"#3-%ED%94%BC%EB%93%9C%EB%B0%B1\" aria-label=\"3 피드백 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 피드백</h2>\n<p>이번에는 필자의 <strong>코드 1</strong>이 Time Limit Exceeded로 실패했습니다. 이에 반해 알고리즘 책의 <strong>코드 2</strong>는 무난하게 통과한 것으로 보입니다. 당연하게도 시간 복잡도상 <strong>코드 2</strong>의 승리입니다. 😥<br>\n<br>\n<strong>코드 1</strong>의 경우, Time Limit 전까지의 테스트는 문제없이 통과한 것으로 보아 알고리즘 자체는 문제가 없는 모양입니다. 비록 시간 복잡도 통과는 못했지만, 아이디어는 간단하게 정리해보겠습니다.</p>\n<ul>\n<li>주어진 연결 리스트들마다 <code class=\"language-text\">head</code>노드(리스트 내 최솟값)를 트래킹 한다.</li>\n<li>트래킹 하는 노드 중 최솟값을 찾아 답에 연결하고, 해당 <code class=\"language-text\">head</code>는 <code class=\"language-text\">next</code>로 넘어간다.</li>\n</ul>\n<p>이러한 방법을 사용할 경우, 최악의 경우를 생각해보면 다음과 같습니다.<br>\n편의상 자료의 개수를 <code class=\"language-text\">n</code>, 트래킹 하는 <code class=\"language-text\">head</code> 개수를 <code class=\"language-text\">n/2</code>라 가정합니다.<br>\n<br>\n<code class=\"language-text\">[1, 2, 3, 4, 5, 6, 7, n/2]</code><br>\n<code class=\"language-text\">[n/2 + 1]</code><br>\n<code class=\"language-text\">[n/2 + 2]</code><br>\n.<br>\n.<br>\n<code class=\"language-text\">[n]</code><br>\n<br>\n위의 경우, <code class=\"language-text\">1</code>을 찾을 때 <code class=\"language-text\">n/2 + 1</code>에서 <code class=\"language-text\">n</code>까지 비교합니다. 그리고 다음 순서인 <code class=\"language-text\">2</code>를 찾을 때도 <code class=\"language-text\">n/2 + 1</code>에서 <code class=\"language-text\">n</code>까지 비교하고, 이는 계속 반복됩니다. 결국 첫 번째 연결 리스트만 해도 연산 과정이 최소 <strong>n/2 * n/2</strong> 이 되고, 시간 복잡도는 <strong>O(n^2)</strong> 입니다.<br>\n<br>\n<strong>코드 2</strong>는 이러한 문제를 <strong>우선순위 큐</strong>(Priority queue)인 <strong>최소 힙</strong>(min heap) 자료구조를 통해 해결합니다. <del>저한테는 놀랍게도</del> 파이썬은 <code class=\"language-text\">heapq</code> 자료구조를 지원하며, 이는 리스트 인덱싱을 기반으로 합니다. 아이디어를 정리하면 다음과 같습니다.<br>\n<br>\n⭐<strong>TIP</strong>⭐ 리스트, 튜플은 대소 비교 연산자를 지원하며 비교는 첫 원소부터 시작한다.</p>\n<ul>\n<li>주어진 k개의 연결 리스트들을 <code class=\"language-text\">heapq</code>에 <code class=\"language-text\">push</code> 한다.</li>\n<li><code class=\"language-text\">push</code>는 튜플(노드 값, 리스트 인덱스, 노드)로 한다. 인덱스는 <code class=\"language-text\">heapq</code>중복 불가 특성상 필요.</li>\n<li><code class=\"language-text\">heapq</code>에서 가장 작은 튜플을 뽑고, 해당 노드를 답에 연결한다.</li>\n<li>뽑은 튜플의 연결 리스트는 다음 노드로 변경해준다. <code class=\"language-text\">heapq</code>가 사라질 때까지 반복한다.</li>\n</ul>\n<p><strong>코드 2</strong>의 경우도 <code class=\"language-text\">heapq</code>를 제외하면 기본적인 알고리즘은 <strong>코드 1</strong>과 비슷합니다. 단지 최솟값을 찾을 때 선형적으로 찾는 것이 아니라 <code class=\"language-text\">heapq</code> 구조에 <code class=\"language-text\">push</code>, <code class=\"language-text\">pop</code>을 반복함으로써 <strong>log(n)</strong> 만에 찾습니다. 이러한 방식을 사용하면 전체적으로 <strong>log(n) * n</strong> 의 시간이 걸리므로 시간 복잡도 <strong>O(nlog(n))</strong> 이 됩니다.</p>\n<h2 id=\"4-요약정리\" style=\"position:relative;\"><a href=\"#4-%EC%9A%94%EC%95%BD%EC%A0%95%EB%A6%AC\" aria-label=\"4 요약정리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. 요약정리</h2>\n<p>우선순위 큐를 사용하는 문제는 <code class=\"language-text\">heapq</code>를 응용해 <strong>O(nlog(n))</strong> 으로 처리하자.<br>\n파이썬은 리스트, 튜플 대소 비교를 지원하며 비교는 첫 원소부터 시작한다.</p>\n<h2 id=\"source\" style=\"position:relative;\"><a href=\"#source\" aria-label=\"source permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Source</h2>\n<ul>\n<li>『파이썬 알고리즘 인터뷰』 <em>-박상길 지음</em><br>\n<a href=\"https://github.com/onlybooks/algorithm-interview\" target=\"_blank\" rel=\"nofollow\">https://github.com/onlybooks/algorithm-interview</a></li>\n<li>leetcode<br>\n<a href=\"https://leetcode.com/problems/merge-k-sorted-lists/\" target=\"_blank\" rel=\"nofollow\">https://leetcode.com/problems/merge-k-sorted-lists/</a></li>\n</ul>","id":"5d823bf8-2a60-5df3-a355-4cfc82f745ab","tableOfContents":"<ul>\n<li><a href=\"#1-%EB%AC%B8%EC%A0%9C-%ED%99%95%EC%9D%B8\">1. 문제 확인</a></li>\n<li><a href=\"#2-%EC%BD%94%EB%93%9C\">2. 코드</a></li>\n<li><a href=\"#3-%ED%94%BC%EB%93%9C%EB%B0%B1\">3. 피드백</a></li>\n<li><a href=\"#4-%EC%9A%94%EC%95%BD%EC%A0%95%EB%A6%AC\">4. 요약정리</a></li>\n<li><a href=\"#source\">Source</a></li>\n</ul>","frontmatter":{"title":"Leetcode 23번 풀이","summary":"Leetcode 23번 k 정렬 리스트 병합 문제 풀이, 우선순위 큐, 힙","date":"2022.11.30.","categories":["Algorithm","Leetcode"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAIAAAAmMtkJAAAACXBIWXMAAAsSAAALEgHS3X78AAACpklEQVQozyWSy0tUcRTHv+f8fvc393rn3nnqVcfmYeNo42OcSXTKwkQaEQa17MVEwThCariJqIgW00OtcNOiQAiloAJ7EEEPo4VQUIsogv6BNrZp1baFcYtz4Ky+33P4fA90prCkBo3iimyGYhAQVZStobhGSQ81KeQtfJlzfq3kxtpsDxCzZSVn3evS4HOVaNQooqHNQxKwgYgSCY/IKOQUGjUMO1p1KHA8XbNbh0O4P2jeGrQvRQX8kiIKAQkA1zvl+RYRZWRsLaNQNLnTUqWolrEEgJGw+Dxbez3rOReTBRNjNrl3auS2ALp8/GqPdsTG2V2RN5Op3QYmQtwXFEwwmfr8vLUx8HayNgV0GJxUBMdDLT6hAwYDhGET5VTN57ul6oHW4ebo9JFxAIaSFrA6s2Pr9+nNav1SK7XqVCeAFp8obFMaWLJrn/JQPqwW9vuqGWvx4oX5hfmepoadGp6cbPzz/dCPh/2Xc6I/yGEJkwEl4BisAC8QlAxgtCd8Z9x7uVI6Vjp+Zqq8Olv+cLX358rA2rGmISApSAEW/xPrDC9TADAINrNXyLk+X9LPIa+9OF1Zmjl1Mx38tJT+8yj7eDSYBhIGhwTq/ostwPsPG4BEnXFlNNZtUTFuHcq0XTlcvDZVuXGw8G42v/Wx9+XRQJYQ1igukRIIMjBZJ4RLCqbisXYzF9b8wPxgYmN9/duXr6+fPV17/mJ5prx5O70y4XQDjqKQQEzAYWBvyM0QQKpWj1tCAzq8fG0o0NgUy3e2D3S297Zt7xLqwQnn/XKXARiS6gUijBC5O90CKCDckbREKaJ2NijADZ+AZkaPxIgjV8adlCQPQSf4yWUERSSJUjrtM6kQkmvFwDYXBXRBOpNi6jW4aPKMj1abRT7sfqLk/3TxFxmUdPFW8MVoAAAAAElFTkSuQmCC"},"images":{"fallback":{"src":"/static/1bbc24e380a98dd7f4db187c8609bb61/18404/leetcode_hard.png","srcSet":"/static/1bbc24e380a98dd7f4db187c8609bb61/b55cb/leetcode_hard.png 200w,\n/static/1bbc24e380a98dd7f4db187c8609bb61/6283e/leetcode_hard.png 400w,\n/static/1bbc24e380a98dd7f4db187c8609bb61/18404/leetcode_hard.png 800w","sizes":"(min-width: 800px) 800px, 100vw"},"sources":[{"srcSet":"/static/1bbc24e380a98dd7f4db187c8609bb61/81933/leetcode_hard.webp 200w,\n/static/1bbc24e380a98dd7f4db187c8609bb61/39863/leetcode_hard.webp 400w,\n/static/1bbc24e380a98dd7f4db187c8609bb61/c2ffc/leetcode_hard.webp 800w","type":"image/webp","sizes":"(min-width: 800px) 800px, 100vw"}]},"width":800,"height":519}},"publicURL":"/static/1bbc24e380a98dd7f4db187c8609bb61/leetcode_hard.png"}}}}]}},"pageContext":{"slug":"/leetcode-23-explanation/"}},"staticQueryHashes":[]}